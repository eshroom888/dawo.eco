"""Research Publisher Service for the Harvester Framework.

Provides a service layer for publishing research items to the Research Pool.
Follows the Harvester Framework pattern: Scanner -> Harvester -> Transformer -> Publisher.

The publisher validates incoming data and delegates persistence to the repository.

Usage:
    from teams.dawo.research import ResearchPublisher, TransformedResearch

    # Create publisher with injected repository
    publisher = ResearchPublisher(repository)

    # Publish research item
    item = TransformedResearch(
        source=ResearchSource.REDDIT,
        title="Research Title",
        content="Content...",
        url="https://reddit.com/...",
    )
    result = await publisher.publish(item)
"""

from datetime import datetime, timezone
from typing import Optional, TYPE_CHECKING
from uuid import UUID, uuid4
import logging
import re

from pydantic import BaseModel, Field, field_validator

from .models import ResearchSource, ComplianceStatus, MAX_SCORE, MIN_SCORE
from .schemas import ResearchItemCreate

# URL validation pattern - must start with http:// or https://
URL_PATTERN = re.compile(r"^https?://\S+$")

if TYPE_CHECKING:
    from .repository import ResearchPoolRepository
    from .models import ResearchItem

# Module logger
logger = logging.getLogger(__name__)


class TransformedResearch(BaseModel):
    """Input schema for research items ready for publishing.

    This schema represents the output of the Transformer stage in the
    Harvester Framework pipeline. All required fields must be populated
    by the transformer before publishing.

    The publisher will generate UUID and timestamp if not provided.
    """

    id: Optional[UUID] = Field(
        default=None,
        description="Optional UUID; generated by publisher if not provided",
    )
    source: ResearchSource = Field(
        ...,
        description="Origin of the research item",
    )
    title: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Headline or summary of the research",
    )
    content: str = Field(
        ...,
        min_length=1,
        description="Full text or transcript excerpt",
    )
    url: str = Field(
        ...,
        max_length=2048,
        description="Source URL for reference",
    )
    tags: list[str] = Field(
        default_factory=list,
        description="Topic/theme tags for categorization",
    )
    source_metadata: dict = Field(
        default_factory=dict,
        description="Source-specific metadata (author, channel, DOI, etc.)",
    )
    score: float = Field(
        default=0.0,
        ge=MIN_SCORE,
        le=MAX_SCORE,
        description="Content potential score (0-10)",
    )
    compliance_status: ComplianceStatus = Field(
        default=ComplianceStatus.COMPLIANT,
        description="EU compliance check result",
    )
    created_at: Optional[datetime] = Field(
        default=None,
        description="Discovery timestamp; defaults to current time",
    )

    @field_validator("tags", mode="before")
    @classmethod
    def validate_tags(cls, v):
        """Ensure tags is a list of strings."""
        if v is None:
            return []
        if isinstance(v, list):
            return [str(tag) for tag in v]
        return [str(v)]

    @field_validator("url")
    @classmethod
    def validate_url(cls, v: str) -> str:
        """Validate URL format - must start with http:// or https://."""
        if not URL_PATTERN.match(v):
            raise ValueError("URL must start with http:// or https://")
        return v

    model_config = {
        "from_attributes": True,
    }


class ResearchPublisher:
    """Service for publishing research items to the Research Pool.

    Follows the Harvester Framework pattern as the final stage:
    Scanner -> Harvester -> Transformer -> Validator -> Publisher -> [Research Pool]

    Accepts repository via dependency injection - NEVER creates repository directly.

    Responsibilities:
    - Validate all required fields before persistence
    - Generate UUID if not provided
    - Set created_at timestamp if not provided
    - Delegate persistence to repository
    """

    def __init__(self, repository: "ResearchPoolRepository"):
        """Initialize publisher with repository.

        Args:
            repository: ResearchPoolRepository instance for persistence.
                       Injected by Team Builder - NEVER create directly.
        """
        self._repository = repository

    async def publish(self, item: TransformedResearch) -> "ResearchItem":
        """Publish a research item to the Research Pool.

        Validates the item, generates ID/timestamp if needed, and
        persists to the database via the repository.

        Args:
            item: Transformed research item ready for publishing

        Returns:
            Created ResearchItem with generated ID

        Raises:
            ValidationError: If item validation fails
            DatabaseError: If persistence fails
        """
        logger.debug("Publishing research item: source=%s, title=%s", item.source, item.title[:50])

        # Convert to repository schema
        create_item = ResearchItemCreate(
            id=item.id,  # Will be generated by repository if None
            source=item.source,
            title=item.title,
            content=item.content,
            url=item.url,
            tags=item.tags,
            source_metadata=item.source_metadata,
            score=item.score,
            compliance_status=item.compliance_status,
            created_at=item.created_at,  # Will be set by repository if None
        )

        # Delegate to repository
        result = await self._repository.add_item(create_item)

        logger.info(
            "Published research item: id=%s, source=%s",
            result.id,
            result.source,
        )

        return result

    async def publish_batch(self, items: list[TransformedResearch]) -> int:
        """Publish multiple research items in a batch.

        More efficient than calling publish() in a loop for large batches.

        Args:
            items: List of transformed research items

        Returns:
            Number of items successfully published

        Raises:
            ValidationError: If any item validation fails
            DatabaseError: If persistence fails
        """
        logger.debug("Publishing batch of %d research items", len(items))

        # Convert all items to create schemas
        create_items = [
            ResearchItemCreate(
                id=item.id,
                source=item.source,
                title=item.title,
                content=item.content,
                url=item.url,
                tags=item.tags,
                source_metadata=item.source_metadata,
                score=item.score,
                compliance_status=item.compliance_status,
                created_at=item.created_at,
            )
            for item in items
        ]

        # Delegate to repository bulk insert
        count = await self._repository.bulk_insert(create_items)

        logger.info("Published batch of %d research items", count)

        return count
